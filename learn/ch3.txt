# ch3.txt
# Chapter 3 - Utilities
# Created by Robert van Engelen
# Distributed under the GPL
________________________________________________________________________________


                    [0;1;34;94mâ–„â–„[0m    [0;1;34;94mâ–„[0;34mâ–„[0m  [0;34mâ–„â–„â–„[0m   [0;34mâ–„â–„[0m   [0;34mâ–„â–„[0;37mâ–„â–„â–„â–„[0m   [0;37mâ–„â–„â–„[0m  [0;37mâ–„â–„â–„[0m 
                    [0;34mâ–ˆâ–ˆ[0m    [0;34mâ–ˆâ–ˆ[0m  [0;34mâ–ˆâ–ˆâ–ˆ[0m   [0;37mâ–ˆâ–ˆ[0m   [0;37mâ–€â–€â–ˆâ–ˆâ–€â–€[0m    [0;1;30;90mâ–ˆâ–ˆâ–„â–„â–ˆâ–ˆ[0m  
                    [0;34mâ–ˆâ–ˆ[0m    [0;34mâ–ˆ[0;37mâ–ˆ[0m  [0;37mâ–ˆâ–ˆâ–€â–ˆ[0m  [0;37mâ–ˆâ–ˆ[0m     [0;1;30;90mâ–ˆâ–ˆ[0m       [0;1;30;90mâ–ˆâ–ˆâ–ˆâ–ˆ[0m   
                    [0;37mâ–ˆâ–ˆ[0m    [0;37mâ–ˆâ–ˆ[0m  [0;37mâ–ˆâ–ˆ[0m [0;37mâ–ˆâ–ˆ[0m [0;1;30;90mâ–ˆâ–ˆ[0m     [0;1;30;90mâ–ˆâ–ˆ[0m        [0;1;34;94mâ–ˆâ–ˆ[0m    
                    [0;37mâ–ˆâ–ˆ[0m    [0;37mâ–ˆ[0;1;30;90mâ–ˆ[0m  [0;1;30;90mâ–ˆâ–ˆ[0m  [0;1;30;90mâ–ˆâ–„â–ˆâ–ˆ[0m     [0;1;34;94mâ–ˆâ–ˆ[0m       [0;1;34;94mâ–ˆâ–ˆâ–ˆâ–ˆ[0m   
                    [0;1;30;90mâ–€â–ˆâ–ˆâ–„â–„â–ˆâ–ˆâ–€[0m  [0;1;30;90mâ–ˆâ–ˆ[0m   [0;1;34;94mâ–ˆâ–ˆâ–ˆ[0m   [0;1;34;94mâ–„â–„â–ˆâ–ˆâ–„â–„[0m    [0;34mâ–ˆâ–ˆ[0m  [0;34mâ–ˆâ–ˆ[0m  
                      [0;1;30;90mâ–€â–€â–€â–€[0m    [0;1;34;94mâ–€â–€[0m   [0;1;34;94mâ–€â–€â–€[0m   [0;1;34;94mâ–€â–€[0;34mâ–€â–€â–€â–€[0m   [0;34mâ–€â–€â–€[0m  [0;34mâ–€â–€â–€[0m 

               [0;1;34;94mâ–„â–„â–„â–„â–„â–„â–„[0;34mâ–„[0m                      [0;37mâ–„â–„â–„â–„[0m               
               [0;34mâ–€â–€â–€â–ˆâ–ˆâ–€â–€â–€[0m                      [0;37mâ–€[0;1;30;90mâ–€â–ˆâ–ˆ[0m               
                  [0;34mâ–ˆâ–ˆ[0m      [0;37mâ–„â–ˆâ–ˆâ–ˆâ–ˆâ–„[0m    [0;37mâ–„â–ˆ[0;1;30;90mâ–ˆâ–ˆâ–ˆâ–„[0m     [0;1;30;90mâ–ˆâ–ˆ[0m      [0;1;34;94mâ–„â–„â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–„[0m 
                  [0;37mâ–ˆâ–ˆ[0m     [0;37mâ–ˆâ–ˆâ–€[0m  [0;1;30;90mâ–€â–ˆâ–ˆ[0m  [0;1;30;90mâ–ˆâ–ˆâ–€[0m  [0;1;30;90mâ–€â–ˆâ–ˆ[0m    [0;1;34;94mâ–ˆâ–ˆ[0m      [0;1;34;94mâ–ˆâ–ˆâ–„â–„â–„â–„[0m [0;34mâ–€[0m 
                  [0;37mâ–ˆâ–ˆ[0m     [0;1;30;90mâ–ˆâ–ˆ[0m    [0;1;30;90mâ–ˆâ–ˆ[0m  [0;1;30;90mâ–ˆâ–ˆ[0m    [0;1;34;94mâ–ˆâ–ˆ[0m    [0;1;34;94mâ–ˆâ–ˆ[0m       [0;34mâ–€â–€â–€â–€â–ˆâ–ˆâ–„[0m 
                  [0;1;30;90mâ–ˆâ–ˆ[0m     [0;1;30;90mâ–€â–ˆâ–ˆâ–„â–„[0;1;34;94mâ–ˆâ–ˆâ–€[0m  [0;1;34;94mâ–€â–ˆâ–ˆâ–„â–„â–ˆâ–ˆâ–€[0m    [0;34mâ–ˆâ–ˆâ–„â–„â–„[0m   [0;34mâ–ˆâ–„â–„â–„â–„â–„â–ˆ[0;37mâ–ˆ[0m 
                  [0;1;30;90mâ–€â–€[0m       [0;1;34;94mâ–€â–€â–€â–€[0m      [0;1;34;94mâ–€[0;34mâ–€â–€â–€[0m       [0;34mâ–€â–€â–€â–€[0m    [0;37mâ–€â–€â–€â–€â–€â–€[0m  


                         #!Chapter 3 - Utilities!


''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
title="Chapter 3 - Utilities"
if [ -d "$HOME/Courses/COP4342/tmp" ]; then workd=$HOME/Courses/COP4342/tmp; fi
demo 'cowsay -f sheep "We will we will rock you!"'
________________________________________________________________________________

  #!Overview!

    â€¢ Listing files

    â€¢ Displaying file contents

    â€¢ Copy, link, move, remove files

    â€¢ Search, sort, print, compare files

    â€¢ Redirecting I/O

    â€¢ Using pipes

    â€¢ Compression and archiving

    â€¢ Communicating with other users

''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
demo 'cowsay -f surgery "Get on with it! Start the operation alright!"'
________________________________________________________________________________

  #!Special characters!

    The following tend to have meaning to the shell, so be careful when trying
    to use them in names:

      & ; | * ? ' " \` [ ] ( ) $ < > { } # / \ ! ~

    Also avoid the following that are reserved in Windows, do not use them in
    filenames if you want to transfer files between Unix/Linux and Windows:
    
      : %
    
    While legal in a filename, avoid "white space" (^!SPACE!, ^!TAB! and ^!ENTER!),
    since spacing is used to separate commands, command options and arguments
    
    The following characters are okay to use in names:

      letters digits _ + , - = @ . (use dot for filename "extensions")

    Most operating systems also support Unicode filenames using UTF-8 encoding

''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
nodemo
________________________________________________________________________________

  #!Quoting special characters!

    You can quote special characters in three ways:

      Escaping them by using a backslash

      Use single quotes

      Use double quotes, but $ and \ are interpreted

    For example:

      *!$ echo '\$PATH'!
      \$PATH
      *!$ echo \\\$PATH!
      \$PATH
      *!$ echo "\\\$PATH = \$PATH"!
      \$PATH = /usr/sbin:/usr/bin:/sbin:/bin

''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
demo 'echo "\$HOME = $HOME"'
________________________________________________________________________________

  #!Using special characters!

    In double quotes use *!\\\\!, *!\\\$! and *!\\"! to escape *!\\!, *!\$! and *!"! respectively
    
      *!$ echo "a \\"backslash\\" \\\\ is used to escape special characters"!
      a "backslash" \ is used to escape special characters

    You cannot use *!\\'! in single quotes, but it works in *!$'...'! (bash)

      *!$ echo $'a \\' is a quote'!
      a ' is a quote

    These *!\\n \\r \\t \\e \\a \\b \\' \\" \\xHH! (hex) *!\\nnn! (octal) also work in *!$'...'!
    
    To enter a key code type a ^!^V! (CONTROL-V) first then hit the key:

      *!$ echo "Hello! ^!^V! ^!TAB! *!world!
      Hello   world

''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
nodemo
________________________________________________________________________________

  #!ls: list files!

    *!ls -a! show hidden dot files and directories, use *!ls -A! to skip _!.! and _!..!

    *!ls -b! show non-graphical characters in a useful fashion

    *!ls -d! named directories are not descended into

    *!ls -i! show inode number

    *!ls -l! show long information

    *!ls -r! reverse the ordering

    *!ls -t! order by modification time

    *!ls -F! show markings for directories (/), executables (*), links (@), etc

    *!ls -C! force multi-column output (default for output to terminals)

''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
nodemo
________________________________________________________________________________

  #!ls: list files with colors!

    *!ls -G! show colorized listing
    
    To always show colorized listings, set enviroment variable *!CLICOLOR=1!
    and optionally environment variable *!LS_COLORS! to set specific color themes:

      *!$ export CLICOLOR=1! (bash)         *!% setenv CLICOLOR -1! (tcsh)
      *!$ export LS_COLORS='di=1;35'!       *!% setenv LS_COLORS 'di=1;35'!

      See also *!dircolors!(1) to generate *!LS_COLORS!, note that Mac OS X and
      FreeBSD use *!LSCOLORS! with a different format e.g. FxGxBxExCxDxdxhbadxcxd

    Some useful shortcuts:

      *!$ alias ll="ls -l"! (bash)          *!% alias ll "ls -l"! (tcsh)

      *!$ alias la="ls -A"! (bash)          *!% alias la "ls -A"! (tcsh)

      *!$ alias l="ls -CF"! (bash)          *!% alias l "ls -CF"! (tcsh)

''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
demo 'more LSCOLORS.txt'
________________________________________________________________________________

  #!Displaying file contents!

    *!cat! takes input from standard input and sends it to standard output

    *!cat FILE1 FILE2! opens _!FILE1! and then _!FILE2! and sends them to stdout
    
    *!more! provides a simple pager to view a file or stdin

      "More is less": *!more! is often aliased to *!less!

    *!less! also provides a pager, but it additionally buffers input so that
    you can go backwards 

    *!head! displays the first lines of a file 

    *!tail! displays the last lines of a file 

''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
nodemo
________________________________________________________________________________

  #!cat FILE1 FILE2 ...: catenate files or stdin!

    Sends file contents catenated to standard output

    *!cat -b! number non-blank lines

    *!cat -n! number the output files

    *!cat -v! display non-printing characters in graphical form

    Utilities that require input typically read stdin when you do not provide a
    file to read:

      *!$ cat!    # blocks on input and reads from the terminal, type ^!^D! (EOF)
               # when you are done

''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
nodemo
________________________________________________________________________________

 #!more [FILE]: more is less!

   *!more! and *!less! are "pagers" and display files or stdin, but *!less! can
   move backwards over the file's content and is more efficient when paging
   through larger files

   *!less! has more options and features than *!more!, which are:

     ^!â†“! or ^!ENTER! go foward one line

     ^!â†‘! go back one line

     ^!SPACE! go forward one page  ^!b! go back one page

     ^!d! go forward half a page   ^!u! go back half a page

     ^!g! go to a line             ^!=! display the current line number

     ^!v! edit file in vi(m)

''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
nodemo
________________________________________________________________________________

 #!less [FILE]: continued!

     ^!/! search forward           ^!?! search backward

     ^!n! repeat search forward    ^!N! repeat search backward

     ^!:n! go to the next file     ^!:p! go to the previous file

     ^!r! or ^!^L! (CONTROL-L) repaint the screen

     ^!R! reload file and repaint the screen, useful when input changes

     ^!h! display a help page

     ^!q! quit

''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
nodemo
________________________________________________________________________________

  #!head [FILE]: display initial lines of a file or stdin!

    *!head -n NUM! print *!NUM! lines

    Default head line count is 10 lines

''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
nodemo
________________________________________________________________________________

  #!tail [FILE]: display final lines of a file or stdin!

    *!tail -n NUM! print *!NUM! lines

    *!tail -f! follow the file as it changes, type ^!^C! to stop:

      *!$ tail -f myprocess.log!    # follow the process log as it changes

    *!tail -r! display lines in reverse order

    Default tail line count is 10 lines

''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
nodemo
________________________________________________________________________________

  #!Common utilities for working with files!

    *!cp! and *!ln! copy/link files and directories

    *!rm! and *!rmdir! remove links, files and directories

    *!mv! move (rename) files and directories

    *!lpr! print a file

    *!grep! search file content

    *!sort! and *!uniq! sort lines in files and filter out repeated lines

    *!diff! and *!cmp! compare two files

    *!locate! and *!find! find the location of files

    *!file! and *!test! determine file type and test existence of a file

''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
nodemo
________________________________________________________________________________

  #!cp SOURCE DEST: copy files and directories!

    *!cp -a! archive; attempts to preserve all attributes in the copy

    *!cp -f! forced: meaning don't ask or complain

    *!cp -i! interactive: asks the user whether or not to copy an item

    *!cp -n! do not overwrite existing file

    *!cp -r! recursively copies files in directories

    You may want to define an alias to avoid accidentally overwriting files:

      *!$ alias cp="cp -i"! (bash)          *!% alias cp "/bin/cp -i"! (tcsh)

''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
nodemo
________________________________________________________________________________

  #!ln SOURCE DEST: link files and directories!

    *!ln -f! forced: meaning don't ask or complain

    *!ln -i! interactive: asks the user whether or not to link an item

    *!ln -s! create a symbolic link instead of a hard link

    It is impossible to create a hard link to a directory in Unix/Linux

    Unix supports the concept of a "symbolic" link (soft link), which is just
    an ordinary flat file which has a bit set that tells the kernel to treat
    the contents of the file as a path to the source location of the file or
    directory

    Some utilities treat symbolic links as regular files and you must use
    option *!-H! or *!L! to let utilities follow the link to access the file
    
      *!tar! does not archive the source file of a symbolic link by default,
      use *!tar -L! to follow symbol links to the sources to archive

''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
rm -f $workd/ch3_demo_hardlinked $workd/ch3_demo_hardlink $workd/ch3_demo_softlinked $workd/ch3_demo_softlink
demo 'touch ch3_demo_hardlinked' 'ln ch3_demo_hardlinked ch3_demo_hardlink' 'echo "This is hardlinked" >> ch3_demo_hardlink' 'ls -l ch3_demo_hardlink*' 'rm ch3_demo_hardlinked' 'cat ch3_demo_hardlink' 'touch ch3_demo_softlinked' 'ln -s ch3_demo_softlinked ch3_demo_softlink' 'echo "This is softlinked" >> ch3_demo_softlink' 'ls -l ch3_demo_softlink*' 'rm ch3_demo_softlinked' 'cat ch3_demo_softlink'
________________________________________________________________________________

 #!rm FILE and rmdir DIR: unlinking and removing files and directories!

   A single file can have many hard links
    
     You can see the hard link count with *!ls -l!

   A process can use the system call *!unlink!(2) to remove a file but not a
   directory

   A process can use the system call *!rmdir!(2) to remove an empty directory 

''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
nodemo
________________________________________________________________________________

  #!rm FILE and rmdir DIR: continued!

    *!rm -i! interactive: asks the user whether or not to remove an item

    *!rm -f! forced: meaning don't ask or complain

    *!rm -r! recursively removes files from directories

    *!rmdir! removes an empty directory

    You may want to define an alias to avoid accidental removal:

      *!$ alias rm="rm -i"! (bash)          *!% alias rm "/bin/rm -i"! (tcsh)

   A common convention in Unix/Linux is to use *!--! to end the options list:

     *!$ rm -f -- -f!    # force-delete a file named _!-f!

''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
demo 'echo "mistake" > -f' 'rm -f -- -f'
________________________________________________________________________________

  #!mv SOURCE DEST: move (rename) files and directories!

    *!mv -f! forced: meaning don't ask or complain

    *!mv -i! interactive: asks the user whether or not to copy an item

    *!mv -n! do not overwrite existing file

    You may want to define an alias to avoid accidentally overwriting files:

      *!$ alias mv="mv -i"! (bash)          *!% alias mv "/bin/mv -i"! (tcsh)

''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
nodemo
________________________________________________________________________________

  #!lpr FILE: print a file!

    *!lpr -P PRINTER! specify *!PRINTER! to print

    *!lpr -# COUNT! print *!COUNT! copies of a file

  #!a2ps FILE: convert text file and print!

    *!a2ps -P PRINTER! send output to *!PRINTER! rather than the default printer

    *!a2ps -o FILE! save output to *!FILE! rather than the default printer

''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
nodemo
________________________________________________________________________________

  #!lpstat -p: list printers!

    Note: consult the CS sysadmin web pages for details on available printers
    and printing policies

  #!lpq: show the current print queue with print jobs!

    *!lpq -l! gives a longer report

  #!lprm JOBID: remove a print job!

    *!lprm -P PRINTER! specify *!PRINTER! to remove the job from

''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
nodemo
________________________________________________________________________________

  #!grep PATTERN FILE1 FILE2 ...: search files or stdin for a pattern!

    *!PATTERN! is a regular expression in basic syntax (POSIX BRE):

      *!.!                   wildcard, matches any character except newline

      *![abc0-9]!            character class with ranges, *![^abc0-9]! is negated

      *!PATTERN1\\|PATTERN2!  alternation

      *!\\(PATTERN\\)!         grouping

      *!PATTERN\\?!           zero or one

      *!PATTERN*!            zero or more

      *!PATTERN\\+!           one or more

      *!PATTERN\\{n,m\\}!      n to m times

''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
nodemo
________________________________________________________________________________

  #!grep PATTERN FILE1 FILE2 ...: continued!

    *!grep -E PATTERN! extended regular expression syntax (POSIX ERE):

      *!.!                  wildcard, matches any character except newline

      *![abc0-9]!           character class with ranges, *![^abc0-9]! is negated

      *!PATTERN1|PATTERN2!  alternation

      *!(PATTERN)!          grouping

      *!PATTERN?!           zero or one

      *!PATTERN*!           zero or more

      *!PATTERN+!           one or more

      *!PATTERN{n,m}!       n to m times

''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
nodemo
________________________________________________________________________________

  #!grep PATTERN FILE1 FILE2 ...: continued!

    Pattern anchors in POSIX BRE and ERE syntax:

      *!^PATTERN!  match at begin of line/string

      *!PATTERN\$! match at end of line/string

      *!\\b!        match word boundary, *!\\B! is negated (not a word boundary)

    Special character classes:

      *!\\w!        match a word character (letter, digit and _)   

      *!\\s!        match a white sapce character

      *![[:C:]]!   match *!upper!, *!lower!, *!space!, *!digit!, *!xdigit!, *!punct!, *!alpha!, *!alnum!

      *![^[:C:]]!  do not match POSIX CLASS C 

''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
nodemo
________________________________________________________________________________

  #!grep PATTERN FILE1 FILE2 ...: continued!

    *!grep -i! ignore case

    *!grep -v! invert match

    *!grep -c! count matching lines

    *!grep -l! show files with matching lines

    *!grep -h! suppress prefixing of filenames

    *!grep -H! print the file name for each match

    *!grep -C LINES! print *!LINES! of context for each match

    *!egrep PATTERN FILE1 FILE2 ...! same as *!grep -E! with ERE syntax

    *!fgrep STRING FILE1 FILE2 ...! fast grep with *!STRING! instead of a pattern

''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
demo 'ls | grep demo' 'ls | grep "ch."' 'grep -c demo *' 'grep -C 1 demo *'
________________________________________________________________________________

  #!sort [FILE]: output FILE or stdin with lines sorted!

    *!sort -u! print only unique lines (like *!sort FILE | uniq!)

    *!sort -b! ignore initial blank lines

    *!sort -n! numerical sort

    *!sort -r! reverse the sort

    *!sort -k! specify a key to sort with

    *!sort -s! stabilize the sort

    *!sort -t SEP! specify a field separator

    *!sort -o FILE! save to *!FILE!

''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
nodemo
________________________________________________________________________________

  #!uniq [FILE]: output FILE or stdin without duplicate lines!

    *!uniq -i! ignore case

    *!uniq -u! only output lines that are not repeated in the input

    *!uniq -d! only output lines that are repeated in the input

''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
nodemo
________________________________________________________________________________

  #!diff FILE1 FILE2: compare two files or directories!

    A common convention in Unix/Linux is to use *!-! (single dash) to read from
    stdin, so you can compare a file to stdin with *!diff - FILE!
  
    *!diff -i! ignore case

    *!diff -b! ignore space change

    *!diff -c! output with context, *!diff -C NUM! with *!NUM! lines

    *!diff -u! output with unified context, *!diff -U NUM! with *!NUM! lines

    *!diff -r! recursively compares files in directories

    An example to create a C++ patch file:

      *!$ diff -u oldfile.cpp newfile.cpp > patch.diff!
      *!$ vi patch.diff!

''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
cat > $workd/ch3_demo_oldfile.cpp << END
#include <iostream>
int main()
{
  std::cout << "Hello world" << std::endl;
}
END
cat > $workd/ch3_demo_newfile.cpp << END
#include <iostream>
int main()
{
  std::cout << "Hello world" << std::endl;
  exit(EXIT_SUCCESS);
}
END
demo 'cat ch3_demo_oldfile.cpp' 'cat ch3_demo_newfile.cpp' 'diff -u ch3_demo_oldfile.cpp ch3_demo_newfile.cpp > ch3_demo_patch.diff' 'cat ch3_demo_patch.diff'
________________________________________________________________________________

  #!cmp FILE1 FILE2: compare two files byte by byte!

    *!cmp -i SKIP! skip the first *!SKIP! bytes

    *!cmp -n LIMIT! compare at most *!LIMIT! bytes

''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
nodemo
________________________________________________________________________________

  #!locate and find: find and locate files!

    *!locate FILE! displays a list of locations where *!FILE! resides

    *!find PATH -name FILE -print! recursively walk *!PATH! to find *!FILE! and print it

      *!$ find /bin -name echo -print!
      /bin/echo

      *!$ find /usr/include -name 'std*.h' -print!
      /usr/include/stddef.h
      /usr/include/stdint.h
      /usr/include/stdio.h
      /usr/include/stdlib.h
      /usr/include/sys/stdio.h

      Note that we used *!'std*.h'! as an argument to *!find -name!, otherwise
      globbing will replace *!std*.h! with a list of files in the current dir!

    The *!find! program is complex and has a lot of features

''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
demo 'find /usr/include -name "std*.h" -print'
________________________________________________________________________________

  #!file FILE: determine file type!

    No really useful options

  #!test OPTION FILE: test existence and attributes of a file or directory!

    *!test -d FILE! exits 0 if *!FILE! is a directory

    *!test -f FILE! exits 0 if *!FILE! is a regular file

    *!test -h FILE! exits 0 if *!FILE! is a symbolic link

    *!test -r FILE! exits 0 if *!FILE! is readable

    *!test -w FILE! exits 0 if *!FILE! is writable

    *!test -x FILE! exits 0 if *!FILE! is executable

''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
demo bash 'file /bin/bash'
________________________________________________________________________________

  #!Program exit status codes!

    After executing a command, *!\$?! holds the exit status code:

      *!$ test -f /doesnotexist!
      *!$ echo \$?!
      1
      *!$ test -d /bin!
      *!$ echo \$?!
      0

    The exit code can be used in a bash *!if-then! (we will talk about bash
    programming later):

      *!$ if test -d /bin; then echo "/bin is a directory"; fi!
      /bin is a directory
      *!$ if test -x /bin/bash; then echo "/bin/bash is executable"; fi!
      /bin/bash is executable

''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
demo bash 'if test -d /bin; then echo "/bin is a directory"; fi'
________________________________________________________________________________

  #!Program exit status codes continued!

    Exit 0 means success and exit nonzero failure, used by this example program:

      *!int! main(*!int! argc, *!char! *argv[])
      {
        *!if! (argc < 1)
          fprintf(stderr, "Usage: readable FILE\n");
        *!else!
        {
          FILE *fd = fopen(argv[1], "r");
          *!if! (fd)
          {
            fclose(fd);
            exit(!m!EXIT_SUCCESS!!); // exit zero
          }
        }
        exit(!m!EXIT_FAILURE!!); // exit nonzero (1)
      }

''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
cat > $workd/ch3_demo_readable.c << END
#include <stdio.h>
#include <stdlib.h>
int main(int argc, char *argv[])
{
  if (argc < 2)
    fprintf(stderr, "Usage: ch1_demo_readable FILE\n");
  else
  {
    FILE *fd = fopen(argv[1], "r");
    if (fd)
    {
      fclose(fd);
      exit(EXIT_SUCCESS);
    }
  }
  exit(EXIT_FAILURE);
}
END
demo bash 'cat ch3_demo_readable.c' 'gcc -o ch3_demo_readable ch3_demo_readable.c' 'if ./ch3_demo_readable ch3_demo_readable.c; then echo yes; fi'
________________________________________________________________________________

  #!Program exit status codes continued!

    The following utilities that we discussed return useful exit status codes:

      *!grep! returns success (0) if at least one line in the input matches

      *!diff! returns success (0) if the two files match

      *!test! returns success (0) if the test is true

    This can be confusing when compared to programming languages such as C,
    because 0 typically means false while 1 means true

    You can list or "chain" commands together with *!&&!:

      *!$ test -x /bin/bash && echo "/bin/bash is executable"!

    There is also a shell *!||! which you can use as a "try this or else":

      *!$ test -d /bin/bash || echo "/bin/bash is not a directory"!

''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
demo bash 'test -d /bin/bash || echo "/bin/bash is not a directory"'
________________________________________________________________________________

  #!Standard I/O!

    By default, processes start with three active file descriptors: 0, 1 and 2

      0 is used for standard input (*!stdin! in C and *!std::cin! in C++)

      1 is used for standard output (*!stdout! in C and *!std::cout! in C++)

      2 is used for standard error (*!stderr! in C and *!std::cerr! in C++)

''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
nodemo
________________________________________________________________________________

  #!I/O redirection!

    You can use *!<! and *!>! for simple input and output redirection:

      *!$ ls -t > outfile!        # save to _!outfile!
      *!$ head -n 1 < outfile!    # show first line of _!outfile!

    This displays the most recently modified file in the current directory

    Never do the following, because it deletes _!myfile.txt!:

      !r!!*!$ sort < myfile.txt > myfile.txt!!    # BAD

    Since *!>! overwrites existing files, you want to make sure to redirect
    output to a non-existing file (unless you intent to overwrite a file):

      !g!!*!$ sort < myfile.txt > myfile.sorted.txt!!    # GOOD

    Novice programmers typically set *!set -o noclobber! (bash) or *!set noclobber!
    (tcsh) to avoid accidentally overwriting files with output redirects

''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
nodemo
________________________________________________________________________________

  #!I/O redirection continued!

    You can be explicit in bash and provide the file descriptor number, such as:

      *!$ ls /doesnotexist 2> errfile!
      *!$ cat errfile!
      ls: /doesnotexist: No such file or directory

    Use *!>>! to append to a file, a new file is created if it does not exist:

      *!$ echo 'The end.' >> myfile.txt!

    Use *!>&! to redirect and merge standard output and standard error:

      *!$ ls /doesnotexist >& out+errfile!
      *!$ cat out+errfile!
      ls: /doesnotexist: No such file or directory

    Use *!2>&1! to indicate that standard error should be redirected to
    standard output, *!1>&2! redirects standard output to standard error

''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
nodemo
________________________________________________________________________________

  #!Redirection via pipes!

    In addition to redirection to a pathname, Unix has long allowed you to join
    the output of a process to the input of another process with a pipe, such as
    
      *!$ ls -t | head -n 1!    # show most recently modified file
      *!$ ls | wc -w!           # number of non-hidden files

    Use *!|&! (tcsh) to pipe and merge both standard output and standard error
    or redirect stderr to stdout with *!2>&1!, for example:

      *!$ ls mayexist |& more!       # tcsh
      *!$ ls mayexist 2>&1 | more!   # bash and tcsh

    You can combine redirects with pipes, for example:

      *!$ sort < myfile.txt | uniq > myfile.sorted.txt!

    Programs can use the Unix *!pipe!(2) system call to create pipes

''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
nodemo
________________________________________________________________________________

  #!tee FILE!

    The *!tee! program is a "pipe fitter" that reads stdin then sends it to
    stdout while saving the data to a file
    
    You can use *!tee! to split the output of one process to another into a
    separate bytestream to stdout:

      *!$ ls | tee outfile!

    This displays the non-hidden files in the current directory and saves the
    output to _!outfile!

    You can fit multiple *!tee! pipes, for example:

      *!$ ls | tee outfile1 | head -n 1 | tee outfile2!

    We will see in Chapter 4 how useful *!tee! is with named pipes for
    inter-process communication
    
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
nodemo
________________________________________________________________________________

  #!Four more utilities!

    *!echo!

    *!date!

    *!script!

    *!unix2dos!

''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
nodemo
________________________________________________________________________________

  #!echo [ARGUMENTS]: send arguments to stdout!

    *!echo! is usually both a binary and a built-in that both support the *!-n!
    option, but not other options

    *!echo -n! do not send an end-of-line

    *!echo -e! (bash) interpret backslash-escaped characters such as *!\\a!,
    *!\\b!, *!\\n!, *!\\r!, *!\\\\!, *!\\xHH! (hex) *!\\0nnn! (octal)

      *!echo \$'...'! (bash) also interprets backslash-escaped characters

''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
nodemo
________________________________________________________________________________

  #!date [FORMAT]: set or display date!

    Example specification formats:

      *!$ date "+DATE: %Y-%m-%d%nTIME: %H:%M:%S"'!
      DATE: 1987-11-21
      TIME: 13:36:16

      *!$ date -u "+%Y-%m-%dT%H:%M:%SZ"!
      2017-12-31T14:05:53Z

    Uses the *!TZ! environment variable to determine the time zone

    Also lets you change the system date, requires root privileges

    The conversion specifications are the same as *!strftime!(3)

''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
demo 'date "+Today is %A %B %d, %Y"'
________________________________________________________________________________

  #!script: make typescript of terminal session!

    This program lets you record your session in a file _!typescript! with lots
    of control characters

    *!script -r! record a session, type ^!^D! or *!exit! to end

    *!script -a! append to the script

    *!script -p! play back a session

''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
rm -f typescript
demo bash 'script -r' 'echo "this is a recorded message"' 'exit' 'script -p'
________________________________________________________________________________

  #!dos2unix and unix2dos!

    Unix and DOS/Windows use different conventions for end of line

      *!\\n! end of line character (Unix)

      *!\\r\\n! carriage return and end of line character (DOS, Windows)
    
    An easy way to convert between the two is with *!dos2unix! and *!unix2dos!

    You can also use *!tr -d '\\r'! to delete *!\\r! from stdin

      *!$ cat memo.dos | tr -d '\\r' > memo.txt!

''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
nodemo
________________________________________________________________________________

  #!Compression and archiving!

    *!xz!, *!unxz! and *!xzcat!

    *!gzip!, *!zcat!, and *!gunzip!

    *!bzip2!, *!bzcat! and *!bunzip2!

    *!zip! and *!unzip!

    *!7z!

    *!tar!

''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
nodemo
________________________________________________________________________________

  #!xz!

    An up and coming format; really nifty how you can just cat two xz files
    together with one command

    *!xz FILE1 FILE2 ...! compress files to _!FILE1.xz! _!FILE2.xz!

    *!xz --stdout! sends compressed stream to stdout, same as *!xzcat!

    Options *!-1!, *!-2!, ... *!-9! offer a choice of fast to best compression

    You can use *!-! in place of a file to read from stdin

  #!unxz: uncompess a .xz file!

    *!unxz FILE1.xz FILE2.xz ...! decompress files to _!FILE1! _!FILE2!

    *!unxz -l! list archive content

    *!unxz --stdout! sends decompressed stream to stdout

''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
nodemo
________________________________________________________________________________

  #!gzip!

    An older but still frequently used compression format

    *!gzip FILE1 FILE2 ...! compress files to _!FILE1.gz! _!FILE2.gz!

    *!gzip --stdout! (or *!-c!) sends compressed stream to stdout, same as *!zcat!

    Options *!-1!, *!-2!, ... *!-9! offer a choice of fast to best compression

    You can use *!-! in place of a file to read from stdin

  #!gunzip: uncompess a .gz file!

    *!gunzip FILE1.gz FILE2.gz ...! decompress files to _!FILE1! _!FILE2!

    *!gunzip -l! list archive content

    *!gunzip --stdout! (or *!-c!) sends decompressed stream to stdout

''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
nodemo
________________________________________________________________________________

  #!bzip2!

    A Burrows-Wheeler block-sorting file compressor, better compression for text

    *!bzip2 FILE1 FILE2 ...! compress files to _!FILE1.bz2! _!FILE2.bz2!

    *!bzip2 --stdout! sends compressed stream to stdout, same as *!bzcat!

    Options *!-1!, *!-2!, ... *!-9! offer a choice of fast to best compression

    You can use *!-! in place of a file to read from stdin

  #!bunzip2: uncompess a .bz2 file!

    *!bunzip2 FILE1.bz2 FILE2.bz2 ...! decompress files to _!FILE1! _!FILE2!

    *!bunzip2 -l! list archive content

    *!bunzip2 --stdout! sends decompressed stream to stdout

''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
nodemo
________________________________________________________________________________

  #!zip!

    Supports the zip format, common in Windows

    *!zip ARCHIVE FILE1 FILE2 ...! compress files to _!ARCHIVE.zip!

    *!zip -d! delete file(s) from archive

    *!zip -r! recursively adds files in directories to the archive

    Options *!-1!, *!-2!, ... *!-9! offer a choice of fast to best compression

    You can use *!-! in place of a file to read from stdin

  #!unzip!

    *!unzip ARCHIVE! decompress files from _!ARCHIVE.zip!

    *!unzip -l! list archive contents

''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
nodemo
________________________________________________________________________________

  #!7z!

    Supports the newer 7-zip high-compression format !m!http://www.7-zip.org!!

    *!7z OPTION ARCHIVE FILE1 FILE2 ...! compress files to _!ARCHIVE.7z!

    *!7z a! add file(s) to archive

    *!7z d! delete file(s) from archive

    *!7z l! list archive contents

    *!7z x! extract file(s) from archive

    *!7z p! set password

    Use *!7z! for files only, 7-zip does not store the owner/group of a file

      To preserve file attributes and to backup directories you should use
      *!tar! with *!7z!

''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
nodemo
________________________________________________________________________________

  #!tar!

    Originally "tape archive"
    
    A "tarball" refers to a format that combines and compresses multiple files

    Allows you to package files together into an archive and newer versions
    automatically recognize compression

    The historical option command syntax (no dashes) is a bit tricky to use

      *!tar c! create a tar (to stdout, unless *!f! is specified)

      *!tar x! extract from a tar file

      *!tar t! print the contents of a tar file

      *!tar f FILE! read or write to the archive *!FILE! (usually a _!.tar!)

      *!tar p! preserve file permissions and ACLs

''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
nodemo
________________________________________________________________________________

  #!tar continued!

    *!tar v! verbose mode

    *!tar z! compress with *!gzip!(1)

    *!tar -C DIR! change directory for this process

    To create a compressed archive backup of all files in the current directory:

      *!$ tar cvfpz backup-171231.tar.gz .!

    To list the archive content:

      *!$ tar tvf backup-171231.tar.gz!

    To expand archive content into the current directory:

      *!$ tar xvf backup-171231.tar.gz!

''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
nodemo
________________________________________________________________________________

  #!Messaging!

    *!write USER [TTY]! starts an interactive session to send messages to
    another *!USER! on *!TTY!, end the messages with ^!^D! (EOF)

    *!mesg y! turns receiving of messages on

    *!mesg n! turns receiving of messages off

    Type ^!^L! (CONTROL-L) to redraw the screen if it gets garbled with messages

''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
nodemo
________________________________________________________________________________

  #!A quick summary!

    Shell commands are utilities, which are built-in or are separate programs

    "Globbing" for example *!ls *.txt!, to prevent globbing, use *!'...'!,
    *!"..."!, or *!\$'...'! (last for bash only)

    *!CMD <! redirect stdin from a file

    *!CMD >! redirect stdout to a file, *!>>! appends to the file

    *!CMD 2>! redirect stderr to a file, *!2>>! appends to the file

    *!CMD 2>&1! redirect (merge) stderr to stdout

    *!CMD >&! redirect stdout and stderr (merged) to a file

    *!CMD1 | CMD2! pipe two commands, sending stdout of *!CMD1! to stdin of *!CMD2!

    *!CMD1 |& CMD2! (tcsh) pipe, stdout and stderr of *!CMD1! to stdin of *!CMD2!

''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
nodemo
________________________________________________________________________________

  #!A quick summary!

    *!CMD --! is often used to end options list

    *!CMD -! is often used to denote stdin where an input file argument is expected

    *!CMD1 ; CMD2! executes two commands in order

    *!CMD &! execute command in the background, use *!fg! to bring it back

    *!nohup CMD &! background-execute command but not killed when shell terminates

    *!CMD1 & CMD2! same, with the second command executing in the foreground

    *!CMd1 && CMD2! conditionally execute the second command if the first succeeded

    *!CMD1 || CMD2! conditionally execute the second command if the first failed

    *!\$?! holds the exit status of the last command

''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
nodemo
